<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AR sem Marcador</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- AR.js com WebXR (para AR sem marcador) -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    .ar-prompt {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 20px;
      z-index: 1000;
      text-align: center;
      font-family: Arial;
    }
  </style>
</head>

<body>
  <!-- Cena AR com detec√ß√£o de superf√≠cie -->
  <a-scene
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true;"
    embedded
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
  >
    
    <!-- Marcador de superf√≠cie (n√£o precisa de padr√£o f√≠sico) -->
    <a-entity id="model"
      gltf-model="70479.glb"
      scale="0.05 0.05 0.05"
      position="0 0 0"
      rotation="0 0 0"
      animation="property: rotation; to: 0 360 0; loop: true; dur: 10000"
      gps-entity-place="latitude: 0; longitude: 0;"
      gesture-handler="minScale: 0.25; maxScale: 4"
      visible="false"
    >
    </a-entity>
    
    <!-- Plano de detec√ß√£o (superf√≠cie) -->
    <a-plane 
      id="floor"
      position="0 0 0"
      rotation="-90 0 0"
      width="100"
      height="100"
      visible="false"
      material="transparent: true; opacity: 0"
      arjs-hit-test="recursive: true"
      raycaster="objects: #model"
    >
    </a-plane>
    
    <!-- C√¢mera -->
    <a-camera 
      id="camera"
      look-controls="enabled: true"
      mouse-cursor
      raycaster="objects: #floor"
    >
      <!-- Cursor para tocar na tela -->
      <a-cursor 
        id="cursor"
        rayOrigin="mouse"
        fuse="true"
        fuseTimeout="500"
      ></a-cursor>
    </a-camera>
    
  </a-scene>
  
  <div class="ar-prompt">
    üëÜ Toque na tela para posicionar a pe√ßa
  </div>
  
  <script>
    // Esperar a cena carregar
    document.querySelector('a-scene').addEventListener('loaded', function() {
      const model = document.querySelector('#model');
      const cursor = document.querySelector('#cursor');
      const floor = document.querySelector('#floor');
      
      // Quando tocar na tela para posicionar
      floor.addEventListener('click', function(evt) {
        const hitPoint = evt.detail.intersection.point;
        
        // Posicionar modelo no ponto tocado
        model.setAttribute('position', {
          x: hitPoint.x,
          y: hitPoint.y,
          z: hitPoint.z
        });
        
        // Tornar vis√≠vel
        model.setAttribute('visible', 'true');
        
        // Remover prompt
        document.querySelector('.ar-prompt').style.display = 'none';
      });
      
      // Rota√ß√£o com toque e arrasto
      let isRotating = false;
      let lastTouchX = 0;
      let lastTouchY = 0;
      
      model.addEventListener('touchstart', function(e) {
        isRotating = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        e.stopPropagation();
      });
      
      model.addEventListener('touchmove', function(e) {
        if (!isRotating) return;
        
        const deltaX = e.touches[0].clientX - lastTouchX;
        const deltaY = e.touches[0].clientY - lastTouchY;
        
        const currentRotation = model.getAttribute('rotation');
        
        // Rotacionar horizontalmente (eixo Y)
        model.setAttribute('rotation', {
          x: currentRotation.x + deltaY * 0.5,
          y: currentRotation.y + deltaX * 0.5,
          z: currentRotation.z
        });
        
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        
        e.preventDefault();
        e.stopPropagation();
      });
      
      model.addEventListener('touchend', function() {
        isRotating = false;
      });
      
      // Zoom com pin√ßa (para dispositivos m√≥veis)
      let initialDistance = 0;
      
      model.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
          initialDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY
          );
        }
      });
      
      model.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2 && isRotating) {
          const currentDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY
          );
          
          const scaleFactor = currentDistance / initialDistance;
          const currentScale = model.getAttribute('scale');
          
          // Limitar escala m√≠nima e m√°xima
          const newScale = {
            x: Math.max(0.01, Math.min(0.2, currentScale.x * scaleFactor)),
            y: Math.max(0.01, Math.min(0.2, currentScale.y * scaleFactor)),
            z: Math.max(0.01, Math.min(0.2, currentScale.z * scaleFactor))
          };
          
          model.setAttribute('scale', newScale);
          initialDistance = currentDistance;
          
          e.preventDefault();
        }
      });
    });
  </script>
</body>
</html>
